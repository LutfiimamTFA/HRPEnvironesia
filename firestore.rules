/**
 * This ruleset enforces a strict security model for the HRP Starter application,
 * balancing user ownership with powerful administrative capabilities.
 *
 * Core Philosophy:
 * The security model is based on user ownership, where users have primary control
 * over their own data. This is augmented by a global 'super_admin' role, which
 * has universal access to all data for administrative purposes.
 *
 * Data Structure:
 * - User-specific data is stored under `/users/{userId}`, directly linking the data
 *   path to the user's authentication ID.
 * - A dedicated, non-public collection `/roles_admin/{userId}` is used as a high-performance
 *   lookup table to identify users with the 'super_admin' role. The mere existence
 *   of a document in this collection grants administrative privileges.
 *
 * Key Security Decisions:
 * - User Enumeration Prevention: Regular users are explicitly blocked from listing the
 *   top-level `/users` collection to protect user privacy.
 * - Privilege Escalation Prevention: The `/roles_admin` collection is made completely
 *   inaccessible from the client-side (read and write). Admin roles must be granted
 *   through a trusted server-side process (e.g., Admin SDK), preventing users from
 *   modifying their own permissions.
 * - Default Deny: All access is denied by default. Rules explicitly grant permissions
 *   based on user identity (ownership) or role (super_admin).
 *
 * Denormalization for Authorization:
 * The use of the `/roles_admin/{userId}` collection is a deliberate denormalization strategy.
 * Instead of performing a costly `get()` on a user's profile document to check their role
 * for every single operation, the rules perform a highly efficient `exists()` check.
 * This makes authorization faster and more scalable.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to create readable, maintainable, and reusable rules.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document
     * by comparing their UID to the document's ID in the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the currently authenticated user has the 'super_admin' role.
     * This is determined by the existence of a corresponding document in the
     * read-only /roles_admin collection. This is faster than a get().
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Gets the role of the currently signed-in user from their user profile.
     * Returns null if the user is not signed in.
     * WARNING: This function uses get() and is NOT safe for list queries.
     */
    function userRole() {
      return isSignedIn()
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role
        : null;
    }
    
    /**
     * Checks if the user has an internal role (e.g., employee, manager).
     * WARNING: This function uses get() and is NOT safe for list queries.
     */
    function isInternal() {
      // isSuperAdmin() is safe for list queries because it uses exists().
      // userRole() is NOT safe for list queries because it uses get().
      return isSuperAdmin() || userRole() in ['hrd', 'manager', 'karyawan'];
    }

    /**
     * Checks if the user is a candidate.
     * WARNING: This function uses get() and is NOT safe for list queries.
     */
    function isCandidate() {
        return userRole() == 'kandidat';
    }

    /**
     * Checks if the user has permissions to manage job postings (create, update, delete).
     * WARNING: This function uses get() and is NOT safe for list queries.
     */
    function canManageJobs() {
      let role = userRole();
      return role == 'super_admin' || role == 'hrd';
    }

    /**
     * Validates that the internal 'uid' field of a document being created matches
     * the user ID from the path. This enforces relational integrity.
     */
    function hasValidCreateData(userId) {
      return request.resource.data.uid == userId;
    }

    /**
     * Validates that the internal 'uid' field of a document being updated is immutable.
     * This prevents re-assigning ownership of the document.
     */
    function hasValidUpdateData() {
      return request.resource.data.uid == resource.data.uid;
    }

    /**
     * @description
     *   Rules for the user profile collection. A user can manage their own
     *   profile, and a super_admin has full access to all profiles.
     * @path
     *   /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if (isOwner(userId) || isSuperAdmin()) && hasValidCreateData(userId);
      allow update: if (isOwner(userId) || isSuperAdmin()) && resource != null && hasValidUpdateData();
      allow delete: if isSuperAdmin() && resource != null;
    }

    /**
     * @description
     *   Rules for the detailed candidate profiles collection.
     *   A candidate can read and write to their own profile.
     *   Internal users can read any profile (get only, not list).
     * @path
     *   /profiles/{userId}
     */
    match /profiles/{userId} {
      allow get: if isOwner(userId) || isInternal();
      allow write: if isOwner(userId); // create, update, delete
    }

    /**
     * @description
     *   This collection is a private lookup table for identifying super_admins.
     *   It is managed exclusively by a trusted server environment and is completely
     *   inaccessible to all clients to prevent privilege escalation.
     * @path
     *   /roles_admin/{userId}
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }
    
    /**
     * @description
     *   Rules for the brands collection. Authenticated users can read brands (e.g., for dropdowns),
     *   but only super_admins can manage them.
     * @path
     *   /brands/{brandId}
     */
    match /brands/{brandId} {
      allow read: if isSignedIn();
      allow create, update, delete: if isSuperAdmin();
    }
    
    /**
     * @description
     *   Rules for job postings. Public can read published jobs. Internal users have
     *   full read access, while only specific roles can write.
     * @path
     *   /jobs/{jobId}
     */
    match /jobs/{jobId} {
      allow read: if resource.data.publishStatus == "published" || isInternal();
      allow create, update, delete: if canManageJobs();
    }

    /**
     * @description
     *   Rules for job applications. Candidates can create and manage their own
     *   applications. Internal users (HRD, Manager) can only get individual
     *   documents, not perform list queries. SuperAdmins have full access.
     */
    match /applications/{applicationId} {
      // READ rules are split into GET and LIST.
      // LIST: A query is allowed if the user is signed in.
      // The query itself MUST be secured on the client-side, e.g., with a
      // where('candidateUid', '==', auth.uid) clause.
      allow list: if isSignedIn();

      // GET: After the list query runs, this rule is checked for EACH document returned.
      // It ensures a user can only receive documents they own, or that an internal
      // user can view any specific document.
      allow get: if (resource.data.candidateUid == request.auth.uid) || isInternal();

      // WRITE rules
      allow create: if isCreatingOwn() && (request.resource.data.status == "draft" || request.resource.data.status == "submitted");
      allow update: if (isOwner() && resource.data.status == "draft") || isInternal();
      allow delete: if isInternal();

      // Helper functions local to this scope for clarity
      function isOwner() {
        return request.auth.uid == resource.data.candidateUid;
      }
      function isCreatingOwn() {
        return request.auth.uid == request.resource.data.candidateUid;
      }
    }

    /**
     * @description
     *   Rules for navigation settings. Only super_admins can read and write.
     *   Other authenticated users can read their own role's settings.
     * @path
     *   /navigation_settings/{roleId}
     */
     match /navigation_settings/{roleId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }
  }
}

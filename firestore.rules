/**
 * This ruleset enforces a strict security model for the HRP Starter application,
 * balancing user ownership with powerful administrative capabilities.
 *
 * Core Philosophy:
 * The security model is based on user ownership, where users have primary control
 * over their own data. This is augmented by a global 'super_admin' role, which
 * has universal access to all data for administrative purposes.
 *
 * Key Security Decisions:
 * - Default Deny: All access is denied by default. Rules explicitly grant permissions.
 * - List vs. Get: Rules for 'list' (queries) must be broad and cannot depend on
 *   document content or cross-document 'get' calls. Rules for 'get' (single doc)
 *   are more specific and are checked after the query runs.
 * - Performant Admin Checks: The super_admin role is checked using exists(),
 *   which is much faster and more scalable than reading a user's profile document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    /**
     * Checks if a user is authenticated. Safe for all queries.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document
     * by comparing their UID to the document's ID in the path. Safe for all queries.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * WARNING: NOT SAFE FOR LIST QUERIES.
     * Checks if the user is a 'super_admin' via a performant existence check.
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * WARNING: NOT SAFE FOR LIST QUERIES.
     * Gets the full user document. Use only in 'get' or 'write' rules.
     * Using this in a 'list' rule will cause the query to be denied.
     */
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    /**
     * WARNING: NOT SAFE FOR LIST QUERIES.
     * Checks if the user has an internal role (e.g., employee, manager).
     */
    function isInternal() {
      let role = getUserData().role;
      return role in ['super-admin', 'hrd', 'manager', 'karyawan'];
    }

    /**
     * Validates incoming data on create to enforce UID integrity.
     */
    function hasValidCreateData(userId) {
      return request.resource.data.uid == userId;
    }

    /**
     * Validates incoming data on update to prevent UID mutation.
     */
    function hasValidUpdateData() {
      return request.resource.data.uid == resource.data.uid;
    }


    // --- Collection Rules ---

    /**
     * /users/{userId}
     * - A user can get/update their own document.
     * - Only a super_admin can list all users or create/delete them.
     */
    match /users/{userId} {
      allow get, update: if isOwner(userId) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if isSuperAdmin() && hasValidCreateData(userId);
      allow delete: if isSuperAdmin();
    }

    /**
     * /profiles/{userId}
     * - A candidate can read and write to their own profile.
     * - Internal users can read any single profile for review purposes.
     */
    match /profiles/{userId} {
      allow get: if isOwner(userId) || isInternal();
      allow write: if isOwner(userId);
    }
    
    /**
     * /roles_admin/{userId}
     * - This is a private lookup table. No client access is allowed.
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }
    
    /**
     * /brands/{brandId}
     * - Brands are public for anyone to read.
     * - Only super_admins can manage (create, update, delete) brands.
     */
    match /brands/{brandId} {
      allow read: if true;
      allow write: if isSuperAdmin();
    }
    
    /**
     * /jobs/{jobId}
     * - Anyone can list jobs (for the careers page).
     * - A single job can be read if it's 'published' or if the user is internal.
     * - Only internal users (hrd, super_admin) can write to jobs.
     */
    match /jobs/{jobId} {
      allow list: if true;
      allow get: if resource.data.publishStatus == "published" || isInternal();
      allow write: if isInternal() && getUserData().role in ['super_admin', 'hrd'];
    }

    /**
     * /applications/{applicationId}
     * - Critical fix for candidate view.
     */
    match /applications/{applicationId} {
        // LIST: Allow a query to proceed if the user is logged in.
        // The client-side query MUST contain `where('candidateUid', '==', request.auth.uid)`.
        // Security is then enforced by the `get` rule below, which Firestore
        // runs on each document in the result set.
        allow list: if isSignedIn();

        // GET: A user can get a document if they are the owner OR if they have an internal role.
        // This `get` rule is evaluated for every document returned by a `list` query.
        allow get: if (resource.data.candidateUid == request.auth.uid) || isInternal();

        // CREATE: A user can create an application only if they are the owner.
        allow create: if isCreatingOwn() && (request.resource.data.status == "draft" || request.resource.data.status == "submitted");
        
        // UPDATE: A candidate can update their own DRAFT. Internal users can update any. candidateUid cannot be changed.
        allow update: if ((isOwner() && resource.data.status == "draft") || isInternal()) && request.resource.data.candidateUid == resource.data.candidateUid;

        // DELETE: Only internal users can delete applications.
        allow delete: if isInternal();

        // Helper functions local to this scope for clarity
        function isOwner() {
            return request.auth.uid == resource.data.candidateUid;
        }
        function isCreatingOwn() {
            return request.auth.uid == request.resource.data.candidateUid;
        }
    }

    /**
     * /navigation_settings/{roleId}
     * - Any signed-in user can read navigation settings to build their UI.
     * - Only super_admins can write/change these settings.
     */
     match /navigation_settings/{roleId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }
    
    // --- Assessment Rules ---

    match /assessment_templates/{templateId} {
      allow read: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super_admin', 'hrd'];
    }

    match /assessments/{assessmentId} {
      allow get: if isSignedIn() && (resource.data.isActive == true || isInternal());
      allow list: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super_admin', 'hrd'];
    }
    
    match /assessment_questions/{questionId} {
      allow list: if isSignedIn();
      allow get: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super_admin', 'hrd'];
    }
    
    match /assessment_sessions/{sessionId} {
      // READ: A user can get their own session. Internal roles can get any session.
      allow get: if isOwner(resource.data.candidateUid) || isInternal();
      
      // LIST: A user can only list their own sessions. Internal roles can list all.
      // This is safe because queries are filtered on the client to check for candidateUid
      allow list: if isSignedIn();

      // CREATE: A user can only create a session for themselves.
      allow create: if isOwner(request.resource.data.candidateUid);
      
      // UPDATE:
      // - A candidate can only update their own session, and only if it's a 'draft'.
      // - Internal roles can update the decision.
      allow update: if (isOwner(resource.data.candidateUid) && resource.data.status == 'draft') || 
                       (isInternal() && isUpdatingHrdDecision());
                       
      // DELETE: No one can delete a session record.
      allow delete: if false;

      function isUpdatingHrdDecision() {
        let allowedUpdateKeys = ['hrdDecision', 'hrdDecisionAt', 'hrdDecisionBy', 'updatedAt'];
        let incomingKeys = request.resource.data.diff(resource.data).affectedKeys();
        
        return 
          // The document must be in 'submitted' state to be decided upon.
          resource.data.status == 'submitted' &&
          
          // The user making the request must be the one recorded in the 'hrdDecisionBy' field of the NEW data.
          request.resource.data.hrdDecisionBy == request.auth.uid &&
          
          // The new decision value must be valid.
          request.resource.data.hrdDecision in ['pending', 'approved', 'rejected'] &&
          
          // The request must be attempting to modify the decision.
          incomingKeys.has('hrdDecision') &&
          
          // All modified keys must be within the allowed set of keys for this operation.
          incomingKeys.subset(allowedUpdateKeys.toSet());
      }
    }
  }
}

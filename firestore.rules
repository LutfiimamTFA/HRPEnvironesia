/**
 * This ruleset enforces a strict security model for the HRP Starter application,
 * balancing user ownership with powerful administrative capabilities.
 *
 * Core Philosophy:
 * The security model is based on user ownership, where users have primary control
 * over their own data. This is augmented by a global 'super_admin' role, which
 * has universal access to all data for administrative purposes.
 *
 * Data Structure:
 * - User-specific data is stored under `/users/{userId}`, directly linking the data
 *   path to the user's authentication ID.
 * - A dedicated, non-public collection `/roles_admin/{userId}` is used as a high-performance
 *   lookup table to identify users with the 'super_admin' role. The mere existence
 *   of a document in this collection grants administrative privileges.
 *
 * Key Security Decisions:
 * - User Enumeration Prevention: Regular users are explicitly blocked from listing the
 *   top-level `/users` collection to protect user privacy.
 * - Privilege Escalation Prevention: The `/roles_admin` collection is made completely
 *   inaccessible from the client-side (read and write). Admin roles must be granted
 *   through a trusted server-side process (e.g., Admin SDK), preventing users from
 *   modifying their own permissions.
 * - Default Deny: All access is denied by default. Rules explicitly grant permissions
 *   based on user identity (ownership) or role (super_admin).
 *
 * Denormalization for Authorization:
 * The use of the `/roles_admin/{userId}` collection is a deliberate denormalization strategy.
 * Instead of performing a costly `get()` on a user's profile document to check their role
 * for every single operation, the rules perform a highly efficient `exists()` check.
 * This makes authorization faster and more scalable.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to create readable, maintainable, and reusable rules.

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document
     * by comparing their UID to the document's ID in the path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the currently authenticated user has the 'super_admin' role.
     * This is determined by the existence of a corresponding document in the
     * read-only /roles_admin collection. This is faster than a get().
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Gets the role of the currently signed-in user from their user profile.
     * Returns null if the user is not signed in.
     */
    function userRole() {
      return isSignedIn()
        ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role
        : null;
    }

    /**
     * Checks if the user has an internal role (e.g., employee, manager).
     * This is used to grant broader read access than the general public.
     */
    function isInternal() {
      // Check for super-admin first to avoid a `get` call if not needed.
      return isSuperAdmin() || userRole() == 'super-admin' || userRole() == 'hrd' || userRole() == 'manager' || userRole() == 'karyawan';
    }

    /**
     * Checks if the user has permissions to manage job postings (create, update, delete).
     */
    function canManageJobs() {
      // Check for super-admin first to avoid a `get` call if not needed.
      return isSuperAdmin() || userRole() == 'super-admin' || userRole() == 'hrd';
    }

    /**
     * Validates that the internal 'uid' field of a document being created matches
     * the user ID from the path. This enforces relational integrity.
     */
    function hasValidCreateData(userId) {
      return request.resource.data.uid == userId;
    }

    /**
     * Validates that the internal 'uid' field of a document being updated is immutable.
     * This prevents re-assigning ownership of the document.
     */
    function hasValidUpdateData() {
      return request.resource.data.uid == resource.data.uid;
    }

    /**
     * @description
     *   Rules for the user profile collection. A user can manage their own
     *   profile, and a super_admin has full access to all profiles.
     * @path
     *   /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if (isOwner(userId) || isSuperAdmin()) && hasValidCreateData(userId);
      allow update: if (isOwner(userId) || isSuperAdmin()) && resource != null && hasValidUpdateData();
      allow delete: if isSuperAdmin() && resource != null;
    }

    /**
     * @description
     *   This collection is a private lookup table for identifying super_admins.
     *   It is managed exclusively by a trusted server environment and is completely
     *   inaccessible to all clients to prevent privilege escalation.
     * @path
     *   /roles_admin/{userId}
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }
    
    /**
     * @description
     *   Rules for the brands collection. Authenticated users can read brands (e.g., for dropdowns),
     *   but only super_admins can manage them.
     * @path
     *   /brands/{brandId}
     */
    match /brands/{brandId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }
    
    /**
     * @description
     *   Rules for job postings. Public can read published jobs. Internal users have
     *   full read access, while only specific roles can write.
     * @path
     *   /jobs/{jobId}
     */
    match /jobs/{jobId} {
      allow read: if (('publishStatus' in resource.data) && resource.data.publishStatus == "published") || isInternal();
      allow write: if canManageJobs();
    }


    /**
     * @description
     *   Rules for navigation settings. Only super_admins can read and write.
     *   Other authenticated users can read their own role's settings.
     * @path
     *   /navigation_settings/{roleId}
     */
     match /navigation_settings/{roleId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }
  }
}

/**
 * This ruleset enforces a strict security model for the HRP Starter application,
 * balancing user ownership with powerful administrative capabilities.
 *
 * Core Philosophy:
 * The security model is based on user ownership, where users have primary control
 * over their own data. This is augmented by a global 'super_admin' role, which
 * has universal access to all data for administrative purposes.
 *
 * Key Security Decisions:
 * - Default Deny: All access is denied by default. Rules explicitly grant permissions.
 * - List vs. Get: Rules for 'list' (queries) must be broad and cannot depend on
 *   document content or cross-document 'get' calls. Rules for 'get' (single doc)
 *   are more specific and are checked after the query runs.
 * - Performant Admin Checks: The super_admin role is checked using exists(),
 *   which is much faster and more scalable than reading a user's profile document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    /**
     * Checks if a user is authenticated. Safe for all queries.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user is the owner of a document
     * by comparing their UID to the document's ID in the path. Safe for all queries.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is a 'super_admin' via a performant existence check.
     * This is safe for list queries when checking against the requesting user's UID.
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Checks if the user's role is 'hrd' via a performant existence check.
     * This is safe for list queries when checking against the requesting user's UID.
     */
    function isHrd() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_hrd/$(request.auth.uid));
    }

    /**
     * WARNING: NOT SAFE FOR LIST QUERIES.
     * Gets the full user document. Use only in 'get' or 'write' rules.
     * Using this in a 'list' rule will cause the query to be denied.
     */
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    /**
     * WARNING: NOT SAFE FOR LIST QUERIES.
     * Checks if the user has an internal role (e.g., employee, manager).
     */
    function isInternal() {
      let role = getUserData().role;
      return role in ['super-admin', 'hrd', 'manager', 'karyawan'];
    }

    /**
     * Validates incoming data on create to enforce UID integrity.
     */
    function hasValidCreateData(userId) {
      return request.resource.data.uid == userId;
    }

    /**
     * Validates incoming data on update to prevent UID mutation.
     */
    function hasValidUpdateData() {
      return request.resource.data.uid == resource.data.uid;
    }


    // --- Collection Rules ---

    /**
     * /users/{userId}
     * - A user can get/update their own document.
     * - Only a super_admin can list all users or create/delete them.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isInternal();
      allow update: if isOwner(userId) || isSuperAdmin();
      allow list: if isSuperAdmin() || isHrd();
      allow create: if (isOwner(userId) && request.resource.data.role == 'kandidat' && hasValidCreateData(userId)) || isSuperAdmin();
      allow delete: if isSuperAdmin();

      match /saved_jobs/{jobId} {
        allow read, write, delete: if isOwner(userId);
      }
    }

    /**
     * /profiles/{userId}
     * - A candidate can read and write to their own profile.
     * - Internal users can read any single profile for review purposes.
     */
    match /profiles/{userId} {
      allow get: if isOwner(userId) || isInternal();
      allow write: if isOwner(userId);
    }
    
    /**
     * /roles_admin/{userId}
     * - This is a private lookup table. No client access is allowed.
     */
    match /roles_admin/{userId} {
      allow read, write: if false;
    }
    
    /**
     * /roles_hrd/{userId}
     * - This is a private lookup table. No client access is allowed.
     */
    match /roles_hrd/{userId} {
      allow read, write: if false;
    }
    
    /**
     * /brands/{brandId}
     * - Brands are public for anyone to read.
     * - Only super_admins can manage (create, update, delete) brands.
     */
    match /brands/{brandId} {
      allow read: if true;
      allow write: if isSuperAdmin();
    }
    
    /**
     * /jobs/{jobId}
     * - Anyone can list jobs (for the careers page).
     * - A single job can be read if it's 'published' or if the user is internal.
     * - Only internal users (hrd, super_admin) can write to jobs.
     */
    match /jobs/{jobId} {
      allow list: if true;
      allow get: if resource.data.publishStatus == "published" || isInternal();
      allow write: if isInternal() && getUserData().role in ['super-admin', 'hrd'];
    }

    /**
     * /applications/{applicationId}
     * - Critical fix for candidate view.
     */
    match /applications/{applicationId} {
        // LIST: Allow a query to proceed if the user is logged in.
        // The client-side query MUST contain `where('candidateUid', '==', request.auth.uid)`.
        // Security is then enforced by the `get` rule below, which Firestore
        // runs on each document in the result set.
        allow list: if isSignedIn();

        // GET: Allow if the user is an admin, the document owner, or an assigned panelist.
        allow get: if isInternal() || !exists(/databases/$(database)/documents/applications/$(applicationId)) || resource.data.candidateUid == request.auth.uid || request.auth.uid in resource.data.allPanelistIds;

        // CREATE: A user can create an application only if they are the owner.
        allow create: if isCreatingOwn() && (request.resource.data.status == "draft" || request.resource.data.status == "submitted");
        
        // UPDATE: A candidate can update their own DRAFT. Internal users can update any. candidateUid cannot be changed.
        allow update: if (
                        (isOwner() && resource.data.status == "draft") ||
                        isSubmittingDocuments() ||
                        isUpdatingSubmittedDocuments() ||
                        isRequestingReschedule() ||
                        (isInternal() && isInternalStatusUpdate()) ||
                        (isInternal() && isUpdatingCvCache())
                      );

        // DELETE: Only internal users can delete applications.
        allow delete: if isInternal();

        // Helper functions local to this scope for clarity
        function isOwner() {
            return request.auth.uid == resource.data.candidateUid;
        }
        function isCreatingOwn() {
            return request.auth.uid == request.resource.data.candidateUid;
        }
        function isSubmittingDocuments() {
            let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
            let allowedKeys = ['cvUrl', 'ijazahUrl', 'cvFileName', 'ijazahFileName', 'status', 'updatedAt'];
            return isOwner()
                && resource.data.status == 'document_submission'
                && request.resource.data.status == 'interview'
                && changedKeys.hasOnly(allowedKeys)
                && request.resource.data.cvUrl is string
                && request.resource.data.ijazahUrl is string;
        }
        function isUpdatingSubmittedDocuments() {
            let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
            let allowedKeys = ['cvUrl', 'ijazahUrl', 'cvFileName', 'ijazahFileName', 'updatedAt'];
            return isOwner()
                && resource.data.status == 'interview'
                && changedKeys.hasOnly(allowedKeys);
        }
        function isUpdatingCvCache() {
            let allowedKeys = ['cvText', 'cvTextExtractedAt', 'cvTextSource', 'cvCharCount'];
            let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
            return isInternal() && changedKeys.hasOnly(allowedKeys);
        }
        function isInternalStatusUpdate() {
            let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
            let allowedKeys = ['status', 'updatedAt', 'personalityTestAssignedAt', 'cvVerified', 'ijazahVerified', 'timeline', 'interviews', 'allPanelistIds'];
            return isInternal() && changedKeys.hasOnly(allowedKeys);
        }
        function isRequestingReschedule() {
          let isOwner = request.auth.uid == resource.data.candidateUid;
          let isInterviewStage = resource.data.status == 'interview';
          let allowedKeys = ['interviews', 'timeline', 'updatedAt'];
          let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
          let onlyAllowedFieldsChanged = changedKeys.hasOnly(allowedKeys);
          return isOwner && isInterviewStage && onlyAllowedFieldsChanged;
        }
    }

    /**
     * /navigation_settings/{roleId}
     * - Any signed-in user can read navigation settings to build their UI.
     * - Only super_admins can write/change these settings.
     */
     match /navigation_settings/{roleId} {
      allow read: if isSignedIn();
      allow write: if isSuperAdmin();
    }
    
    // --- Assessment Rules ---

    match /assessment_config/{configId} {
      allow get: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super-admin', 'hrd'];
    }

    match /assessment_templates/{templateId} {
      allow read: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super-admin', 'hrd'];
    }

    match /assessments/{assessmentId} {
      allow get: if isSignedIn() && (resource.data.isActive == true || isInternal());
      allow list: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super-admin', 'hrd'];
    }
    
    match /assessment_questions/{questionId} {
      allow list: if isSignedIn(); // Must be relatively open for where-in queries. Client logic is the main guard.
      allow get: if isSignedIn();
      allow write: if isInternal() && getUserData().role in ['super-admin', 'hrd'];
    }
    
    match /assessment_sessions/{sessionId} {
      // READ: A user can get their own session. Internal roles can get any session.
      allow get: if isOwner(resource.data.candidateUid) || isInternal();
      
      // LIST: A user can only list their own sessions. Internal roles can list all.
      // This is safe because queries are filtered on the client to check for candidateUid
      allow list: if isSignedIn();

      // CREATE: A user can only create a session for themselves.
      allow create: if isOwner(request.resource.data.candidateUid);
      
      // UPDATE:
      // - A candidate can only update their own session, and only if it's a 'draft'.
      // - Internal roles can update the decision.
      allow update: if (isOwner(resource.data.candidateUid) && resource.data.status == 'draft') || 
                       isUpdatingHrdDecision();
                       
      // DELETE: No one can delete a session record.
      allow delete: if false;

      function isUpdatingHrdDecision() {
        let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
        let allowedUpdateKeys = ['hrdDecision', 'hrdDecisionAt', 'hrdDecisionBy', 'updatedAt'];
        
        return isInternal()
          && resource.data.status == 'submitted'
          && changedKeys.hasOnly(allowedUpdateKeys)
          && request.resource.data.hrdDecisionBy == request.auth.uid
          && request.resource.data.hrdDecision in ['pending', 'approved', 'rejected'];
      }
    }
  }
}
